//this is the driver code for the big 16x16 led panel
#include "masks.h"
#include <SPI.h>

#define PIN_CLOCK  14
#define PIN_DATA_A  12
#define	PIN_DATA_B  13
#define PIN_STROBE 05


#define SYMBOL_COUNT 38
//byte width should be 32 eventually; but may reduce by 4 if combine leds






unsigned char disp2[SYMBOL_COUNT][BYTE_COUNT] = {
  {0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C}, //0
  {0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10}, //1
  {0x7E, 0x02, 0x02, 0x7E, 0x40, 0x40, 0x40, 0x7E}, //2
  {0x3E, 0x02, 0x02, 0x3E, 0x02, 0x02, 0x3E, 0x00}, //3
  {0x08, 0x18, 0x28, 0x48, 0xFE, 0x08, 0x08, 0x08}, //4
  {0x3C, 0x20, 0x20, 0x3C, 0x04, 0x04, 0x3C, 0x00}, //5
  {0x3C, 0x20, 0x20, 0x3C, 0x24, 0x24, 0x3C, 0x00}, //6
  {0x3E, 0x22, 0x04, 0x08, 0x08, 0x08, 0x08, 0x08}, //7
  {0x00, 0x3E, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3E}, //8
  {0x3E, 0x22, 0x22, 0x3E, 0x02, 0x02, 0x02, 0x3E}, //9
  {0x08, 0x14, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x22}, //A
  {0x3C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3C, 0x00}, //B
  {0x3C, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3C, 0x00}, //C
  {0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00}, //D
  {0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x7C}, //E
  {0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40}, //F
  {0x3C, 0x40, 0x40, 0x40, 0x40, 0x44, 0x44, 0x3C}, //G
  {0x44, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44, 0x44}, //H
  {0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C}, //I
  {0x3C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x48, 0x30}, //J
  {0x00, 0x24, 0x28, 0x30, 0x20, 0x30, 0x28, 0x24}, //K
  {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C}, //L
  {0x81, 0xC3, 0xA5, 0x99, 0x81, 0x81, 0x81, 0x81}, //M
  {0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00}, //N
  {0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C}, //O
  {0x3C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20}, //P
  {0x1C, 0x22, 0x22, 0x22, 0x22, 0x26, 0x22, 0x1D}, //Q
  {0x3C, 0x22, 0x22, 0x22, 0x3C, 0x24, 0x22, 0x21}, //R
  {0x00, 0x1E, 0x20, 0x20, 0x3E, 0x02, 0x02, 0x3C}, //S
  {0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}, //T
  {0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22, 0x1C}, //U
  {0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18}, //V
  {0x00, 0x49, 0x49, 0x49, 0x49, 0x2A, 0x1C, 0x00}, //W
  {0x00, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41}, //X
  {0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08}, //Y
  {0x00, 0x7F, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7F}, //Z
};

/*
 * Like shiftOut, but uses 1 clock for 2 data lines at same time
 */
void shiftOutDual(uint8_t clockPin, uint8_t dataPinA, uint8_t dataPinB, uint8_t bitOrder, uint8_t valA, uint8_t valB)
{
  uint8_t i;

  for (i = 0; i < 8; i++)  {
    if (bitOrder == LSBFIRST){
      
      digitalWrite(dataPinA, !!(valA & (1 << i)));
      digitalWrite(dataPinB, !!(valB & (1 << i)));
    }
    else{
      digitalWrite(dataPinA, !!(valA & (1 << (7 - i))));
      digitalWrite(dataPinB, !!(valB & (1 << (7 - i))));
    }
      
    digitalWrite(clockPin, HIGH);
    digitalWrite(clockPin, LOW);    
  }
}

void writeDay(dateTime dt)
{
  
}

void writeTime()

/*
 * takes in 256 bits to write to the display
 */
void writeToMatrix(uint8_t mask[])
{
  uint8_t _lineA;//left half of a row goes in first
  uint8_t _lineB;

  for (int i = 7; i >=0; i--) {
    _lineA = 0;
    _lineA = 
    ((mask[0] & (1<<i))>>i)>>7 |
    ((mask[0] & (1<<i))>>i)>>6 |
    ((mask[1] & (1<<i))>>i)>>5 |
    ((mask[1] & (1<<i))>>i)>>4 |
    ((mask[2] & (1<<i))>>i)>>3 |
    ((mask[2] & (1<<i))>>i)>>2 |
    ((mask[3] & (1<<i))>>i)>>1 |
    ((mask[3] & (1<<i))>>i)>>0;
    
    _lineB = 0;
    _lineB =
    ((mask[4] & (1<<i))>>i)>>7 |
    ((mask[4] & (1<<i))>>i)>>6 |
    ((mask[5] & (1<<i))>>i)>>5 |
    ((mask[5] & (1<<i))>>i)>>4 |
    ((mask[6] & (1<<i))>>i)>>3 |
    ((mask[6] & (1<<i))>>i)>>2 |
    ((mask[7] & (1<<i))>>i)>>1 |
    ((mask[7] & (1<<i))>>i)>>0;
    
    shiftOutDual(PIN_CLOCK, PIN_DATA_A, PIN_DATA_B, MSBFIRST, _lineA, _lineB);
    shiftOutDual(PIN_CLOCK, PIN_DATA_A, PIN_DATA_B, MSBFIRST, _lineA, _lineB);
  }
}

void setup()
{
  pinMode(PIN_CLOCK, OUTPUT);
  pinMode(PIN_DATA_A, OUTPUT);
  pinMode(PIN_DATA_B, OUTPUT);
  pinMode(PIN_STROBE, OUTPUT);

  //SPI.begin();

  analogWrite(PIN_STROBE, 192);

}

void loop()
{
  //  byte randByte = (byte)random(-127,128);
  //  shiftOut(PIN_DATA_A, PIN_CLOCK, MSBFIRST, randByte);
  //
  //  delay(100);

  for (int j = 0; j < SYMBOL_COUNT; j++)
  {
    for (int k = 0; k < 4; k++) {
      for (int i = 0; i < BYTE_COUNT; i++)
      {
        shiftOut(PIN_DATA_A, PIN_CLOCK, MSBFIRST, disp2[j][i]);
        //SPI.transfer(disp2[j][i]);
      }
    }
    delay(1000); //wait half a second
  }
}
